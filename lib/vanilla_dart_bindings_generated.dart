// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/vanilla_dart.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class VanillaDartBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  VanillaDartBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  VanillaDartBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Int> _VANILLA_SUCCESS =
      _lookup<ffi.Int>('VANILLA_SUCCESS');

  int get VANILLA_SUCCESS => _VANILLA_SUCCESS.value;

  late final ffi.Pointer<ffi.Int> _VANILLA_ERROR =
      _lookup<ffi.Int>('VANILLA_ERROR');

  int get VANILLA_ERROR => _VANILLA_ERROR.value;

  late final ffi.Pointer<ffi.Int> _VANILLA_READY =
      _lookup<ffi.Int>('VANILLA_READY');

  int get VANILLA_READY => _VANILLA_READY.value;

  late final ffi.Pointer<ffi.Int> _VANILLA_INFO =
      _lookup<ffi.Int>('VANILLA_INFO');

  int get VANILLA_INFO => _VANILLA_INFO.value;

  late final ffi.Pointer<ffi.Int> _VANILLA_UNKNOWN_COMMAND =
      _lookup<ffi.Int>('VANILLA_UNKNOWN_COMMAND');

  int get VANILLA_UNKNOWN_COMMAND => _VANILLA_UNKNOWN_COMMAND.value;

  late final ffi.Pointer<ffi.Int> _VANILLA_INVALID_ARGUMENT =
      _lookup<ffi.Int>('VANILLA_INVALID_ARGUMENT');

  int get VANILLA_INVALID_ARGUMENT => _VANILLA_INVALID_ARGUMENT.value;

  /// Start listening for gamepad commands
  int vanilla_start(
    vanilla_event_handler_t event_handler,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _vanilla_start(
      event_handler,
      context,
    );
  }

  late final _vanilla_startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(vanilla_event_handler_t,
              ffi.Pointer<ffi.Void>)>>('vanilla_start');
  late final _vanilla_start = _vanilla_startPtr.asFunction<
      int Function(vanilla_event_handler_t, ffi.Pointer<ffi.Void>)>();

  int vanilla_start_udp(
    vanilla_event_handler_t event_handler,
    ffi.Pointer<ffi.Void> context,
    int server_address,
  ) {
    return _vanilla_start_udp(
      event_handler,
      context,
      server_address,
    );
  }

  late final _vanilla_start_udpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(vanilla_event_handler_t, ffi.Pointer<ffi.Void>,
              ffi.Uint32)>>('vanilla_start_udp');
  late final _vanilla_start_udp = _vanilla_start_udpPtr.asFunction<
      int Function(vanilla_event_handler_t, ffi.Pointer<ffi.Void>, int)>();

  /// Attempt to stop the current action
  ///
  /// This can be called from another thread to safely exit a blocking call to vanilla_start().
  void vanilla_stop() {
    return _vanilla_stop();
  }

  late final _vanilla_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('vanilla_stop');
  late final _vanilla_stop = _vanilla_stopPtr.asFunction<void Function()>();

  /// Set button/axis state
  ///
  /// This can be called from another thread to change the button state while vanilla_connect_to_console() is running.
  ///
  /// For buttons, anything non-zero will be considered a press.
  /// For axes, the range is signed 16-bit (-32,768 to 32,767).
  /// For accelerometers, cast a float value in m/s^2.
  /// For gyroscopes, cast a float value in radians per second.
  void vanilla_set_button(
    int button,
    int value,
  ) {
    return _vanilla_set_button(
      button,
      value,
    );
  }

  late final _vanilla_set_buttonPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Int32)>>(
          'vanilla_set_button');
  late final _vanilla_set_button =
      _vanilla_set_buttonPtr.asFunction<void Function(int, int)>();

  /// Set touch screen coordinates to `x` and `y`
  ///
  /// This can be called from another thread to change the button state while vanilla_connect_to_console() is running.
  ///
  /// `x` and `y` are expected to be in gamepad screen coordinates (0x0 to 853x479).
  /// If either `x` or `y` are -1, this point will be disabled.
  void vanilla_set_touch(
    int x,
    int y,
  ) {
    return _vanilla_set_touch(
      x,
      y,
    );
  }

  late final _vanilla_set_touchPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int, ffi.Int)>>(
          'vanilla_set_touch');
  late final _vanilla_set_touch =
      _vanilla_set_touchPtr.asFunction<void Function(int, int)>();

  /// Logging function
  void vanilla_log(
    ffi.Pointer<ffi.Char> format,
  ) {
    return _vanilla_log(
      format,
    );
  }

  late final _vanilla_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'vanilla_log');
  late final _vanilla_log =
      _vanilla_logPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  void vanilla_log_no_newline(
    ffi.Pointer<ffi.Char> format,
  ) {
    return _vanilla_log_no_newline(
      format,
    );
  }

  late final _vanilla_log_no_newlinePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'vanilla_log_no_newline');
  late final _vanilla_log_no_newline = _vanilla_log_no_newlinePtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  void vanilla_log_no_newline_va(
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _vanilla_log_no_newline_va(
      format,
      args,
    );
  }

  late final _vanilla_log_no_newline_vaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vanilla_log_no_newline_va');
  late final _vanilla_log_no_newline_va =
      _vanilla_log_no_newline_vaPtr.asFunction<
          void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  /// Install custom logger
  void vanilla_install_logger(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>
        logger,
  ) {
    return _vanilla_install_logger(
      logger,
    );
  }

  late final _vanilla_install_loggerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Char>,
                              ffi.Pointer<__va_list_tag>)>>)>>(
      'vanilla_install_logger');
  late final _vanilla_install_logger = _vanilla_install_loggerPtr.asFunction<
      void Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>)>();

  /// Request an IDR (instant decoder refresh) video frame from the console
  void vanilla_request_idr() {
    return _vanilla_request_idr();
  }

  late final _vanilla_request_idrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('vanilla_request_idr');
  late final _vanilla_request_idr =
      _vanilla_request_idrPtr.asFunction<void Function()>();

  /// Retrieve SPS/PPS data for H.264 encoding
  ///
  /// If `data` is null, `*size` will be set to the number of bytes required.
  /// If `data` is not null, bytes will be copied up to `*size` or the total number of bytes.
  void vanilla_retrieve_sps_pps_data(
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _vanilla_retrieve_sps_pps_data(
      data,
      size,
    );
  }

  late final _vanilla_retrieve_sps_pps_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Size>)>>('vanilla_retrieve_sps_pps_data');
  late final _vanilla_retrieve_sps_pps_data =
      _vanilla_retrieve_sps_pps_dataPtr.asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Size>)>();

  /// Sets the region Vanilla should present itself to the console
  ///
  /// The gamepad is region locked and the console will complain if the gamepad doesn't match.
  ///
  /// Set to a member of the VanillaRegion enum.
  void vanilla_set_region(
    int region,
  ) {
    return _vanilla_set_region(
      region,
    );
  }

  late final _vanilla_set_regionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'vanilla_set_region');
  late final _vanilla_set_region =
      _vanilla_set_regionPtr.asFunction<void Function(int)>();

  /// Sets the gamepad battery status that Vanilla should send to the console
  void vanilla_set_battery_status(
    int battery_status,
  ) {
    return _vanilla_set_battery_status(
      battery_status,
    );
  }

  late final _vanilla_set_battery_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'vanilla_set_battery_status');
  late final _vanilla_set_battery_status =
      _vanilla_set_battery_statusPtr.asFunction<void Function(int)>();
}

abstract class VanillaGamepadButtons {
  static const int VANILLA_BTN_A = 0;
  static const int VANILLA_BTN_B = 1;
  static const int VANILLA_BTN_X = 2;
  static const int VANILLA_BTN_Y = 3;
  static const int VANILLA_BTN_L = 4;
  static const int VANILLA_BTN_R = 5;
  static const int VANILLA_BTN_ZL = 6;
  static const int VANILLA_BTN_ZR = 7;
  static const int VANILLA_BTN_MINUS = 8;
  static const int VANILLA_BTN_PLUS = 9;
  static const int VANILLA_BTN_HOME = 10;
  static const int VANILLA_BTN_L3 = 11;
  static const int VANILLA_BTN_R3 = 12;
  static const int VANILLA_BTN_LEFT = 13;
  static const int VANILLA_BTN_RIGHT = 14;
  static const int VANILLA_BTN_DOWN = 15;
  static const int VANILLA_BTN_UP = 16;
  static const int VANILLA_AXIS_L_X = 17;
  static const int VANILLA_AXIS_L_Y = 18;
  static const int VANILLA_AXIS_R_X = 19;
  static const int VANILLA_AXIS_R_Y = 20;
  static const int VANILLA_AXIS_L_LEFT = 21;
  static const int VANILLA_AXIS_L_UP = 22;
  static const int VANILLA_AXIS_L_RIGHT = 23;
  static const int VANILLA_AXIS_L_DOWN = 24;
  static const int VANILLA_AXIS_R_LEFT = 25;
  static const int VANILLA_AXIS_R_UP = 26;
  static const int VANILLA_AXIS_R_RIGHT = 27;
  static const int VANILLA_AXIS_R_DOWN = 28;
  static const int VANILLA_AXIS_VOLUME = 29;
  static const int VANILLA_SENSOR_ACCEL_X = 30;
  static const int VANILLA_SENSOR_ACCEL_Y = 31;
  static const int VANILLA_SENSOR_ACCEL_Z = 32;
  static const int VANILLA_SENSOR_GYRO_PITCH = 33;
  static const int VANILLA_SENSOR_GYRO_YAW = 34;
  static const int VANILLA_SENSOR_GYRO_ROLL = 35;
  static const int VANILLA_BTN_COUNT = 36;
}

abstract class VanillaEvent {
  static const int VANILLA_EVENT_VIDEO = 0;
  static const int VANILLA_EVENT_AUDIO = 1;
  static const int VANILLA_EVENT_VIBRATE = 2;
}

abstract class VanillaRegion {
  static const int VANILLA_REGION_JAPAN = 0;
  static const int VANILLA_REGION_AMERICA = 1;
  static const int VANILLA_REGION_EUROPE = 2;
  static const int VANILLA_REGION_CHINA = 3;
  static const int VANILLA_REGION_SOUTH_KOREA = 4;
  static const int VANILLA_REGION_TAIWAN = 5;
  static const int VANILLA_REGION_AUSTRALIA = 6;
}

abstract class VanillaBatteryStatus {
  static const int VANILLA_BATTERY_STATUS_CHARGING = 0;
  static const int VANILLA_BATTERY_STATUS_UNKNOWN = 1;
  static const int VANILLA_BATTERY_STATUS_VERY_LOW = 2;
  static const int VANILLA_BATTERY_STATUS_LOW = 3;
  static const int VANILLA_BATTERY_STATUS_MEDIUM = 4;
  static const int VANILLA_BATTERY_STATUS_HIGH = 5;
  static const int VANILLA_BATTERY_STATUS_FULL = 6;
}

/// Event handler used by caller to receive events
typedef vanilla_event_handler_t
    = ffi.Pointer<ffi.NativeFunction<vanilla_event_handler_tFunction>>;
typedef vanilla_event_handler_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> context,
    ffi.Int event_type,
    ffi.Pointer<ffi.Char> data,
    ffi.Size data_size);
typedef Dartvanilla_event_handler_tFunction = void Function(
    ffi.Pointer<ffi.Void> context,
    int event_type,
    ffi.Pointer<ffi.Char> data,
    int data_size);

final class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}
